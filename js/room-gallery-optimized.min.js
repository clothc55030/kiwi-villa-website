(function() {
'use strict';
class RoomGalleryOptimized {
constructor() {
this.galleries = [];
this.rafId = null;
this.init();
}
init() {
if ('requestIdleCallback' in window) {
requestIdleCallback(() => this.setupGalleries());
} else {
setTimeout(() => this.setupGalleries(), 100);
}
}
setupGalleries() {
const galleryElements = document.querySelectorAll('.room-gallery');
galleryElements.forEach(gallery => {
const galleryInstance = {
element: gallery,
items: gallery.querySelectorAll('.gallery-item'),
currentIndex: 0,
isScrolling: false,
touchStartX: 0,
touchStartY: 0,
scrollStartLeft: 0
};
if (galleryInstance.items.length > 1) {
this.setupGallery(galleryInstance);
this.galleries.push(galleryInstance);
}
});
}
setupGallery(gallery) {
this.createIndicators(gallery);
this.setupTouchEvents(gallery);
this.setupLazyLoading(gallery);
this.setupScrollListener(gallery);
}
createIndicators(gallery) {
if (gallery.element.querySelector('.gallery-indicators')) return;
const fragment = document.createDocumentFragment();
const container = document.createElement('div');
container.className = 'gallery-indicators';
gallery.items.forEach((_, index) => {
const indicator = document.createElement('div');
indicator.className = `gallery-indicator ${index === 0 ? 'active' : ''}`;
indicator.dataset.index = index;
indicator.addEventListener('click', () => {
this.scrollToImage(gallery, index);
});
container.appendChild(indicator);
});
fragment.appendChild(container);
gallery.element.appendChild(fragment);
gallery.indicators = container.querySelectorAll('.gallery-indicator');
}
setupTouchEvents(gallery) {
const element = gallery.element;
let touchStartTime;
element.addEventListener('touchstart', (e) => {
gallery.touchStartX = e.touches[0].pageX;
gallery.touchStartY = e.touches[0].pageY;
gallery.scrollStartLeft = element.scrollLeft;
gallery.isScrolling = true;
touchStartTime = Date.now();
element.style.scrollBehavior = 'auto';
}, { passive: true });
element.addEventListener('touchmove', (e) => {
if (!gallery.isScrolling) return;
const touchX = e.touches[0].pageX;
const touchY = e.touches[0].pageY;
const deltaX = gallery.touchStartX - touchX;
const deltaY = gallery.touchStartY - touchY;
if (Math.abs(deltaY) > Math.abs(deltaX)) {
gallery.isScrolling = false;
return;
}
if (this.rafId) cancelAnimationFrame(this.rafId);
this.rafId = requestAnimationFrame(() => {
element.scrollLeft = gallery.scrollStartLeft + deltaX;
});
}, { passive: true });
element.addEventListener('touchend', (e) => {
if (!gallery.isScrolling) return;
gallery.isScrolling = false;
element.style.scrollBehavior = 'smooth';
const touchEndTime = Date.now();
const touchDuration = touchEndTime - touchStartTime;
const touchEndX = e.changedTouches[0].pageX;
const velocity = (gallery.touchStartX - touchEndX) / touchDuration;
if (Math.abs(velocity) > 0.5) {
const direction = velocity > 0 ? 1 : -1;
const newIndex = Math.max(0, Math.min(gallery.items.length - 1, gallery.currentIndex + direction));
this.scrollToImage(gallery, newIndex);
} else {
this.snapToNearestImage(gallery);
}
}, { passive: true });
}
setupScrollListener(gallery) {
let scrollTimeout;
gallery.element.addEventListener('scroll', () => {
clearTimeout(scrollTimeout);
scrollTimeout = setTimeout(() => {
requestAnimationFrame(() => {
this.updateActiveIndicator(gallery);
});
}, 100);
}, { passive: true });
}
setupLazyLoading(gallery) {
const imageObserver = new IntersectionObserver((entries) => {
entries.forEach(entry => {
if (entry.isIntersecting) {
const img = entry.target.querySelector('img');
if (img && img.dataset.src && !img.src) {
const picture = img.closest('picture');
if (picture) {
const sources = picture.querySelectorAll('source[data-srcset]');
sources.forEach(source => {
source.srcset = source.dataset.srcset;
});
}
img.src = img.dataset.src;
img.classList.add('lazyloaded');
}
}
});
}, {
root: gallery.element,
rootMargin: '50px 0px',
threshold: 0.01
});
gallery.items.forEach(item => {
imageObserver.observe(item);
});
}
scrollToImage(gallery, index) {
const item = gallery.items[index];
if (!item) return;
gallery.currentIndex = index;
const scrollLeft = item.offsetLeft - (gallery.element.offsetWidth - item.offsetWidth) / 2;
gallery.element.scrollTo({
left: scrollLeft,
behavior: 'smooth'
});
this.updateActiveIndicator(gallery);
}
snapToNearestImage(gallery) {
const scrollLeft = gallery.element.scrollLeft;
const containerWidth = gallery.element.offsetWidth;
let nearestIndex = 0;
let minDistance = Infinity;
gallery.items.forEach((item, index) => {
const itemCenter = item.offsetLeft + item.offsetWidth / 2;
const containerCenter = scrollLeft + containerWidth / 2;
const distance = Math.abs(itemCenter - containerCenter);
if (distance < minDistance) {
minDistance = distance;
nearestIndex = index;
}
});
this.scrollToImage(gallery, nearestIndex);
}
updateActiveIndicator(gallery) {
if (!gallery.indicators) return;
const scrollLeft = gallery.element.scrollLeft;
const containerWidth = gallery.element.offsetWidth;
const containerCenter = scrollLeft + containerWidth / 2;
let activeIndex = 0;
let minDistance = Infinity;
gallery.items.forEach((item, index) => {
const itemCenter = item.offsetLeft + item.offsetWidth / 2;
const distance = Math.abs(itemCenter - containerCenter);
if (distance < minDistance) {
minDistance = distance;
activeIndex = index;
}
});
gallery.currentIndex = activeIndex;
gallery.indicators.forEach((indicator, index) => {
indicator.classList.toggle('active', index === activeIndex);
});
}
}
if (document.readyState === 'loading') {
document.addEventListener('DOMContentLoaded', () => {
new RoomGalleryOptimized();
});
} else {
new RoomGalleryOptimized();
}
window.RoomGalleryOptimized = RoomGalleryOptimized;
})();